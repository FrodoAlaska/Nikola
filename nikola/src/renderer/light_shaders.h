#pragma once

#include "nikola/nikola_gfx.h"

inline nikola::GfxShaderDesc generate_blinn_phong_shader() {
  return nikola::GfxShaderDesc {
    "#version 460 core\n"
    "\n"
    "// Layouts\n"
    "layout (location = 0) in vec3 aPos;\n"
    "layout (location = 1) in vec3 aNormal;\n"
    "layout (location = 2) in vec2 aTexCoords;\n"
    "\n"
    "// Uniform block\n"
    ""
    "layout(std140, binding = 0) uniform Matrices {\n"
    "  mat4 u_view;\n"
    "  mat4 u_projection;\n"
    "  vec3 u_camera_pos;\n"
    "};\n"
    ""
    "layout(std140, binding = 1) uniform InstanceBuffer {"
    "  mat4 u_model[1024];"
    "};"
    ""
    "// Outputs\n"
    "out VS_OUT {"
    "  vec2 tex_coords;"
    "  vec3 normal;"
    "  vec3 pixel_pos;"
    "  vec3 camera_pos;"
    "} vs_out;"
    "\n"
    "void main() {\n"
    "  vec4 model_space = u_model[gl_InstanceID] * vec4(aPos, 1.0f);"
    "\n"
    "  vs_out.tex_coords = aTexCoords;"
    "  vs_out.normal     = mat3(transpose(inverse(u_model[gl_InstanceID]))) * aNormal;"
    "  vs_out.pixel_pos  = vec3(model_space);"
    "  vs_out.camera_pos = u_camera_pos;"
    "\n"
    "  gl_Position = u_projection * u_view * model_space;"
    "}\n",

    "#version 460 core"
    "\n"
    "layout (location = 0) out vec4 frag_color;"
    "\n"
    "in VS_OUT {"
    "  vec2 tex_coords;"
    "  vec3 normal;" 
    "  vec3 pixel_pos;"
    "  vec3 camera_pos;"
    "} fs_in;"
    "\n"
    "#define POINT_LIGHTS_MAX 16"
    "\n"
    "struct Material {"
    "  sampler2D diffuse_map;"
    "  sampler2D specular_map;"
    "\n"
    "  vec3 color;"
    "  float shininess;"
    "  float transparency;"
    "};"
    "\n"
    "struct DirectionalLight {"
    "  vec3 direction;" 
    "  vec3 color;" 
    "};"
    "\n"
    "struct PointLight {"
    "  vec3 position;" 
    "  vec3 color;" 
    "\n"
    "  float linear;"
    "  float quadratic;"
    "};"
    ""
    "uniform Material u_material;"
    ""
    "uniform DirectionalLight u_dir_light;"
    "uniform PointLight u_point_lights[POINT_LIGHTS_MAX];"
    "uniform int u_point_lights_count;"
    ""
    "uniform vec3 u_ambient;"
    ""
    "vec3 accumulate_point_lights_color(const vec3 diffuse_texel, const vec3 specular_texel, const int points_max) {"
    "  vec3 ambient  = u_ambient * diffuse_texel;"
    "  vec3 norm     = normalize(fs_in.normal);"
    "  vec3 view_dir = normalize(fs_in.camera_pos - fs_in.pixel_pos);"
    ""
    "  vec3 point_lights_factor = vec3(0.0f);"
    "  for(int i = 0; i < points_max; i++) {"
    ""
    "   // Diffuse\n"
    " "  
    "   vec3 light_dir = normalize(u_point_lights[i].position - fs_in.pixel_pos);"
    "   float diff     = max(dot(norm, light_dir), 0.0);"
    "   vec3 diffuse   = diff * diffuse_texel;"
    ""
    "   // Specular\n"
    ""
    "   vec3 halfway_dir = normalize(light_dir + view_dir);"
    "   float spec       = pow(max(dot(norm, halfway_dir), 0.0), u_material.shininess);"
    "   vec3 specular    = spec * specular_texel;"
    ""
    "   // Apply attenuation\n"
    ""
    "   float distance = length(u_point_lights[i].position - fs_in.pixel_pos);"
    "   float atten    = 1.0 / (1.0 + u_point_lights[i].linear * distance + u_point_lights[i].quadratic * (distance * distance));"
    ""
    "   diffuse  *= atten; "
    "   specular *= atten;"
    ""
    "   point_lights_factor += (diffuse + specular) * u_point_lights[i].color;"
    " }"
    ""
    "   return ambient + point_lights_factor;"
    "}\n"
    ""
    "vec3 accumulate_dir_light_color(const vec3 diffuse_texel, const vec3 specular_texel) {"
    ""
    "  // Diffuse\n"
    " "
    "  vec3 light_dir = normalize(-u_dir_light.direction);"
    "  vec3 norm      = normalize(fs_in.normal);"
    "  float diff     = max(dot(norm, light_dir), 0.0);"
    "  vec3 diffuse   = diff * diffuse_texel;"
    ""
    "  // Specular\n"
    ""
    "  vec3 view_dir    = normalize(fs_in.camera_pos - fs_in.pixel_pos);"
    "  vec3 halfway_dir = normalize(light_dir + view_dir);"
    "  float spec       = pow(max(dot(norm, halfway_dir), 0.0), u_material.shininess);"
    "  vec3 specular    = spec * specular_texel;"
    ""
    "  return (diffuse + specular) * u_dir_light.color;"
    "}\n"
    "\n"
    "void main() {"
    "  vec3 diffuse  = texture(u_material.diffuse_map, fs_in.tex_coords).rgb * u_material.color;"
    "  vec3 specular = texture(u_material.specular_map, fs_in.tex_coords).rgb * u_material.color;"
    ""
    "  // Clamp the max point lights\n"
    ""
    "  int points_max = u_point_lights_count;"
    "  if(points_max > POINT_LIGHTS_MAX) {\n"
    "    points_max = POINT_LIGHTS_MAX;"
    "  }\n"
    ""
    "  // Gather the light factors from all the light sources\n"
    "" 
    "  vec3 point_lights_factor = accumulate_point_lights_color(diffuse, specular, points_max);"
    "  vec3 dir_light_factor    = accumulate_dir_light_color(diffuse, specular);"
    "\n"
    "  frag_color = vec4(vec3(point_lights_factor + dir_light_factor), u_material.transparency);"
    "}"
    "\n"
  };
};
